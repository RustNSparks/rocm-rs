/* automatically generated by rust-bindgen 0.71.1 */

#[doc = " \\brief Represents a discrete probability distribution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocrand_discrete_distribution_st {
    #[doc = " Number of entries in the probability table"]
    pub size: ::std::os::raw::c_uint,
    #[doc = " The distribution can be offset"]
    pub offset: ::std::os::raw::c_uint,
    #[doc = " Alias table"]
    pub alias: *mut ::std::os::raw::c_uint,
    #[doc = "Probability data for the alias table"]
    pub probability: *mut f64,
    #[doc = " Cumulative distribution function"]
    pub cdf: *mut f64,
}
pub type rocrand_discrete_distribution = *mut rocrand_discrete_distribution_st;
#[repr(C)]
#[derive(Debug)]
pub struct __half {
    pub __x: ::std::os::raw::c_ushort,
}
#[doc = " \\cond ROCRAND_DOCS_TYPEDEFS\n rocRAND half type (derived from HIP)"]
pub type half = __half;
pub type uint4 = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocrand_generator_base_type {
    _unused: [u8; 0],
}
#[doc = " \\cond ROCRAND_DOCS_TYPEDEFS\n rocRAND random number generator (opaque)"]
pub type rocrand_generator = *mut rocrand_generator_base_type;
#[doc = "< No errors"]
pub const rocrand_status_ROCRAND_STATUS_SUCCESS: rocrand_status = 0;
#[doc = "< Header file and linked library version do not match"]
pub const rocrand_status_ROCRAND_STATUS_VERSION_MISMATCH: rocrand_status = 100;
#[doc = "< Generator was not created using rocrand_create_generator"]
pub const rocrand_status_ROCRAND_STATUS_NOT_CREATED: rocrand_status = 101;
#[doc = "< Memory allocation failed during execution"]
pub const rocrand_status_ROCRAND_STATUS_ALLOCATION_FAILED: rocrand_status = 102;
#[doc = "< Generator type is wrong"]
pub const rocrand_status_ROCRAND_STATUS_TYPE_ERROR: rocrand_status = 103;
#[doc = "< Argument out of range"]
pub const rocrand_status_ROCRAND_STATUS_OUT_OF_RANGE: rocrand_status = 104;
#[doc = "< Requested size is not a multiple of quasirandom generator's dimension,\n< or requested size is not even (see rocrand_generate_normal()),\n< or pointer is misaligned (see rocrand_generate_normal())"]
pub const rocrand_status_ROCRAND_STATUS_LENGTH_NOT_MULTIPLE: rocrand_status = 105;
#[doc = "< GPU does not have double precision"]
pub const rocrand_status_ROCRAND_STATUS_DOUBLE_PRECISION_REQUIRED: rocrand_status = 106;
#[doc = "< Kernel launch failure"]
pub const rocrand_status_ROCRAND_STATUS_LAUNCH_FAILURE: rocrand_status = 107;
#[doc = "< Internal library error"]
pub const rocrand_status_ROCRAND_STATUS_INTERNAL_ERROR: rocrand_status = 108;
#[doc = " \\brief rocRAND function call status type"]
pub type rocrand_status = ::std::os::raw::c_uint;
#[doc = "< Default pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_DEFAULT: rocrand_rng_type = 400;
#[doc = "< XORWOW pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_XORWOW: rocrand_rng_type = 401;
#[doc = "< MRG32k3a pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_MRG32K3A: rocrand_rng_type = 402;
#[doc = "< Mersenne Twister MTGP32 pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_MTGP32: rocrand_rng_type = 403;
#[doc = "< PHILOX-4x32-10 pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_PHILOX4_32_10: rocrand_rng_type = 404;
#[doc = "< MRG31k3p pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_MRG31K3P: rocrand_rng_type = 405;
#[doc = "< LFSR113 pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_LFSR113: rocrand_rng_type = 406;
#[doc = "< Mersenne Twister MT19937 pseudorandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_MT19937: rocrand_rng_type = 407;
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_THREEFRY2_32_20: rocrand_rng_type = 408;
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_THREEFRY2_64_20: rocrand_rng_type = 409;
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_THREEFRY4_32_20: rocrand_rng_type = 410;
pub const rocrand_rng_type_ROCRAND_RNG_PSEUDO_THREEFRY4_64_20: rocrand_rng_type = 411;
#[doc = "< Default quasirandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_QUASI_DEFAULT: rocrand_rng_type = 500;
#[doc = "< Sobol32 quasirandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_QUASI_SOBOL32: rocrand_rng_type = 501;
#[doc = "< Scrambled Sobol32 quasirandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_QUASI_SCRAMBLED_SOBOL32: rocrand_rng_type = 502;
#[doc = "< Sobol64 quasirandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_QUASI_SOBOL64: rocrand_rng_type = 504;
#[doc = "< Scrambled Sobol64 quasirandom generator"]
pub const rocrand_rng_type_ROCRAND_RNG_QUASI_SCRAMBLED_SOBOL64: rocrand_rng_type = 505;
#[doc = " \\brief rocRAND generator type"]
pub type rocrand_rng_type = ::std::os::raw::c_uint;
#[doc = "< Best ordering for pseudorandom results"]
pub const rocrand_ordering_ROCRAND_ORDERING_PSEUDO_BEST: rocrand_ordering = 100;
#[doc = "< Default ordering for pseudorandom results"]
pub const rocrand_ordering_ROCRAND_ORDERING_PSEUDO_DEFAULT: rocrand_ordering = 101;
#[doc = "< Fast lower quality pseudorandom results"]
pub const rocrand_ordering_ROCRAND_ORDERING_PSEUDO_SEEDED: rocrand_ordering = 102;
#[doc = "< Legacy ordering for pseudorandom results"]
pub const rocrand_ordering_ROCRAND_ORDERING_PSEUDO_LEGACY: rocrand_ordering = 103;
pub const rocrand_ordering_ROCRAND_ORDERING_PSEUDO_DYNAMIC: rocrand_ordering = 104;
#[doc = "< n-dimensional ordering for quasirandom results"]
pub const rocrand_ordering_ROCRAND_ORDERING_QUASI_DEFAULT: rocrand_ordering = 201;
#[doc = " \\brief rocRAND generator ordering"]
pub type rocrand_ordering = ::std::os::raw::c_uint;
pub const rocrand_direction_vector_set_ROCRAND_DIRECTION_VECTORS_32_JOEKUO6:
    rocrand_direction_vector_set = 101;
pub const rocrand_direction_vector_set_ROCRAND_SCRAMBLED_DIRECTION_VECTORS_32_JOEKUO6:
    rocrand_direction_vector_set = 102;
pub const rocrand_direction_vector_set_ROCRAND_DIRECTION_VECTORS_64_JOEKUO6:
    rocrand_direction_vector_set = 103;
pub const rocrand_direction_vector_set_ROCRAND_SCRAMBLED_DIRECTION_VECTORS_64_JOEKUO6:
    rocrand_direction_vector_set = 104;
#[doc = " \\brief rocRAND vector set"]
pub type rocrand_direction_vector_set = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief Creates a new random number generator.\n\n Creates a new pseudo random number generator of type \\p rng_type\n and returns it in \\p generator.\n\n Values for \\p rng_type are:\n - ROCRAND_RNG_PSEUDO_XORWOW\n - ROCRAND_RNG_PSEUDO_MRG31K3P\n - ROCRAND_RNG_PSEUDO_MRG32K3A\n - ROCRAND_RNG_PSEUDO_MTGP32\n - ROCRAND_RNG_PSEUDO_PHILOX4_32_10\n - ROCRAND_RNG_PSEUDO_LFSR113\n - ROCRAND_RNG_PSEUDO_THREEFRY2_32_20\n - ROCRAND_RNG_PSEUDO_THREEFRY2_64_20\n - ROCRAND_RNG_PSEUDO_THREEFRY4_32_20\n - ROCRAND_RNG_PSEUDO_THREEFRY4_64_20\n - ROCRAND_RNG_QUASI_SOBOL32\n - ROCRAND_RNG_QUASI_SCRAMBLED_SOBOL32\n - ROCRAND_RNG_QUASI_SOBOL64\n - ROCRAND_RNG_QUASI_SCRAMBLED_SOBOL64\n\n \\param generator - Pointer to generator\n \\param rng_type - Type of generator to create\n\n \\return\n - ROCRAND_STATUS_ALLOCATION_FAILED, if memory could not be allocated \\n\n - ROCRAND_STATUS_VERSION_MISMATCH if the header file version does not match the\n   dynamically linked library version \\n\n - ROCRAND_STATUS_TYPE_ERROR if the value for \\p rng_type is invalid \\n\n - ROCRAND_STATUS_SUCCESS if generator was created successfully \\n\n"]
    pub fn rocrand_create_generator(
        generator: *mut rocrand_generator,
        rng_type: rocrand_rng_type,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a new host random number generator.\n\n Creates a new pseudo random number generator of type \\p rng_type\n and returns it in \\p generator. This generator is executed on the host rather than\n on a device, and it is enqueued on the stream associated with the generator.\n\n All generators are supported.\n\n \\param generator - Pointer to generator\n \\param rng_type - Type of generator to create\n\n \\return\n - ROCRAND_STATUS_ALLOCATION_FAILED, if memory could not be allocated \\n\n - ROCRAND_STATUS_VERSION_MISMATCH if the header file version does not match the\n   dynamically linked library version \\n\n - ROCRAND_STATUS_TYPE_ERROR if the value for \\p rng_type is invalid \\n\n - ROCRAND_STATUS_SUCCESS if generator was created successfully \\n\n"]
    pub fn rocrand_create_generator_host(
        generator: *mut rocrand_generator,
        rng_type: rocrand_rng_type,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Creates a new host random number generator, similar to `rocrand_create_generator_host`.\n   The exception is that, instead of enqueuing the host function in the stream,\n   execution happens synchronously with respect to the calling thread and the stream is ignored."]
    pub fn rocrand_create_generator_host_blocking(
        generator: *mut rocrand_generator,
        rng_type: rocrand_rng_type,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Destroys random number generator.\n\n Destroys random number generator and frees related memory.\n\n \\param generator - Generator to be destroyed\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_SUCCESS if generator was destroyed successfully \\n"]
    pub fn rocrand_destroy_generator(generator: rocrand_generator) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed 32-bit unsigned integers.\n\n Generates \\p n uniformly distributed 32-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^32, including \\p 0 and\n excluding \\p 2^32.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 32-bit unsigned integers to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate(
        generator: rocrand_generator,
        output_data: *mut ::std::os::raw::c_uint,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed 64-bit unsigned integers.\n\n Generates \\p n uniformly distributed 64-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^64, including \\p 0 and\n excluding \\p 2^64.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 64-bit unsigned integers to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_TYPE_ERROR if the generator can't natively generate 64-bit random numbers \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_long_long(
        generator: rocrand_generator,
        output_data: *mut ::std::os::raw::c_ulonglong,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed 8-bit unsigned integers.\n\n Generates \\p n uniformly distributed 8-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^8, including \\p 0 and\n excluding \\p 2^8.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 8-bit unsigned integers to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_char(
        generator: rocrand_generator,
        output_data: *mut ::std::os::raw::c_uchar,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed 16-bit unsigned integers.\n\n Generates \\p n uniformly distributed 16-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^16, including \\p 0 and\n excluding \\p 2^16.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 16-bit unsigned integers to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_short(
        generator: rocrand_generator,
        output_data: *mut ::std::os::raw::c_ushort,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed \\p float values.\n\n Generates \\p n uniformly distributed 32-bit floating-point values\n and saves them to \\p output_data.\n\n Generated numbers are between \\p 0.0f and \\p 1.0f, excluding \\p 0.0f and\n including \\p 1.0f.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>float</tt>s to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_uniform(
        generator: rocrand_generator,
        output_data: *mut f32,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed double-precision floating-point values.\n\n Generates \\p n uniformly distributed 64-bit double-precision floating-point\n values and saves them to \\p output_data.\n\n Generated numbers are between \\p 0.0 and \\p 1.0, excluding \\p 0.0 and\n including \\p 1.0.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>double</tt>s to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_uniform_double(
        generator: rocrand_generator,
        output_data: *mut f64,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates uniformly distributed half-precision floating-point values.\n\n Generates \\p n uniformly distributed 16-bit half-precision floating-point\n values and saves them to \\p output_data.\n\n Generated numbers are between \\p 0.0 and \\p 1.0, excluding \\p 0.0 and\n including \\p 1.0.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>half</tt>s to generate\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_uniform_half(
        generator: rocrand_generator,
        output_data: *mut half,
        n: usize,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates normally distributed \\p float values.\n\n Generates \\p n normally distributed distributed 32-bit floating-point\n values and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>float</tt>s to generate\n \\param mean - Mean value of normal distribution\n \\param stddev - Standard deviation value of normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_normal(
        generator: rocrand_generator,
        output_data: *mut f32,
        n: usize,
        mean: f32,
        stddev: f32,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates normally distributed \\p double values.\n\n Generates \\p n normally distributed 64-bit double-precision floating-point\n numbers and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>double</tt>s to generate\n \\param mean - Mean value of normal distribution\n \\param stddev - Standard deviation value of normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_normal_double(
        generator: rocrand_generator,
        output_data: *mut f64,
        n: usize,
        mean: f64,
        stddev: f64,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates normally distributed \\p half values.\n\n Generates \\p n normally distributed 16-bit half-precision floating-point\n numbers and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>half</tt>s to generate\n \\param mean - Mean value of normal distribution\n \\param stddev - Standard deviation value of normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_normal_half(
        generator: rocrand_generator,
        output_data: *mut half,
        n: usize,
        mean: half,
        stddev: half,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates log-normally distributed \\p float values.\n\n Generates \\p n log-normally distributed 32-bit floating-point values\n and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>float</tt>s to generate\n \\param mean - Mean value of log normal distribution\n \\param stddev - Standard deviation value of log normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_log_normal(
        generator: rocrand_generator,
        output_data: *mut f32,
        n: usize,
        mean: f32,
        stddev: f32,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates log-normally distributed \\p double values.\n\n Generates \\p n log-normally distributed 64-bit double-precision floating-point\n values and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>double</tt>s to generate\n \\param mean - Mean value of log normal distribution\n \\param stddev - Standard deviation value of log normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_log_normal_double(
        generator: rocrand_generator,
        output_data: *mut f64,
        n: usize,
        mean: f64,
        stddev: f64,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates log-normally distributed \\p half values.\n\n Generates \\p n log-normally distributed 16-bit half-precision floating-point\n values and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of <tt>half</tt>s to generate\n \\param mean - Mean value of log normal distribution\n \\param stddev - Standard deviation value of log normal distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_log_normal_half(
        generator: rocrand_generator,
        output_data: *mut half,
        n: usize,
        mean: half,
        stddev: half,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Generates Poisson-distributed 32-bit unsigned integers.\n\n Generates \\p n Poisson-distributed 32-bit unsigned integers and\n saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 32-bit unsigned integers to generate\n \\param lambda - lambda for the Poisson distribution\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if lambda is non-positive \\n\n - ROCRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - ROCRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn rocrand_generate_poisson(
        generator: rocrand_generator,
        output_data: *mut ::std::os::raw::c_uint,
        n: usize,
        lambda: f64,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Initializes the generator's state on GPU or host.\n\n Initializes the generator's state on GPU or host. User it not\n required to call this function before using a generator.\n\n If rocrand_initialize() was not called for a generator, it will be\n automatically called by functions which generates random numbers like\n rocrand_generate(), rocrand_generate_uniform() etc.\n\n \\param generator - Generator to initialize\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_LAUNCH_FAILURE if a HIP kernel launch failed \\n\n - ROCRAND_STATUS_SUCCESS if the seeds were generated successfully \\n"]
    pub fn rocrand_initialize_generator(generator: rocrand_generator) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the current stream for kernel launches.\n\n Sets the current stream for all kernel launches of the generator.\n All functions will use this stream.\n\n \\param generator - Generator to modify\n \\param stream - Stream to use or NULL for default stream\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_SUCCESS if stream was set successfully \\n"]
    pub fn rocrand_set_stream(generator: rocrand_generator, stream: hipStream_t) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the seed of a pseudo-random number generator.\n\n Sets the seed of the pseudo-random number generator.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's offset.\n\n For an MRG32K3a or MRG31K3p generator the seed value can't be zero. If \\p seed is\n equal to zero and generator's type is ROCRAND_RNG_PSEUDO_MRG32K3A or ROCRAND_RNG_PSEUDO_MRG31K3P,\n value \\p 12345 is used as seed instead.\n\n For a LFSR113 generator seed values must be larger than 1, 7, 15,\n 127. The \\p seed upper and lower 32 bits used as first and\n second seed value. If those values smaller than 2 and/or 8, those\n are increased with 1 and/or 7.\n\n \\param generator - Pseudo-random number generator\n \\param seed - New seed value\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_TYPE_ERROR if the generator is a quasi-random number generator \\n\n - ROCRAND_STATUS_SUCCESS if seed was set successfully \\n"]
    pub fn rocrand_set_seed(
        generator: rocrand_generator,
        seed: ::std::os::raw::c_ulonglong,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the seeds of a pseudo-random number generator.\n\n Sets the seed of the pseudo-random number generator. Currently only for LFSR113\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's offset.\n\n Only usable for LFSR113.\n\n For a LFSR113 generator seed values must be bigger than 1, 7, 15,\n 127. If those values smaller, than the requested minimum values [2, 8, 16, 128], then\n it will be increased with the minimum values minus 1 [1, 7, 15, 127].\n\n \\param generator - Pseudo-random number generator\n \\param seed - New seed value\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_TYPE_ERROR if the generator is a quasi-random number generator \\n\n - ROCRAND_STATUS_SUCCESS if seed was set successfully \\n"]
    pub fn rocrand_set_seed_uint4(generator: rocrand_generator, seed: uint4) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the offset of a random number generator.\n\n Sets the absolute offset of the random number generator.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's seed.\n\n Absolute offset cannot be set if generator's type is ROCRAND_RNG_PSEUDO_MTGP32 or\n ROCRAND_RNG_PSEUDO_LFSR113.\n\n \\param generator - Random number generator\n \\param offset - New absolute offset\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_SUCCESS if offset was successfully set \\n\n - ROCRAND_STATUS_TYPE_ERROR if generator's type is ROCRAND_RNG_PSEUDO_MTGP32 or\n ROCRAND_RNG_PSEUDO_LFSR113"]
    pub fn rocrand_set_offset(
        generator: rocrand_generator,
        offset: ::std::os::raw::c_ulonglong,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the ordering of a random number generator.\n\n Sets the ordering of the results of a random number generator.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's seed.\n\n \\param generator - Random number generator\n \\param order - New ordering of results\n\n The ordering choices for pseudorandom sequences are the following.\n Note that not all generators support all orderings. For details, see\n the Programmer's Guide in the documentation.\n - ROCRAND_ORDERING_PSEUDO_DEFAULT\n - ROCRAND_ORDERING_PSEUDO_LEGACY\n - ROCRAND_ORDERING_PSEUDO_BEST\n - ROCRAND_ORDERING_PSEUDO_SEEDED\n - ROCRAND_ORDERING_PSEUDO_DYNAMIC\n\n For quasirandom sequences there is only one ordering, ROCRAND_ORDERING_QUASI_DEFAULT.\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if the ordering is not valid \\n\n - ROCRAND_STATUS_SUCCESS if the ordering was successfully set \\n\n - ROCRAND_STATUS_TYPE_ERROR if generator's type is not valid"]
    pub fn rocrand_set_ordering(
        generator: rocrand_generator,
        order: rocrand_ordering,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Set the number of dimensions of a quasi-random number generator.\n\n Set the number of dimensions of a quasi-random number generator.\n Supported values of \\p dimensions are 1 to 20000.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's offset.\n\n \\param generator - Quasi-random number generator\n \\param dimensions - Number of dimensions\n\n \\return\n - ROCRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - ROCRAND_STATUS_TYPE_ERROR if the generator is not a quasi-random number generator \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p dimensions is out of range \\n\n - ROCRAND_STATUS_SUCCESS if the number of dimensions was set successfully \\n"]
    pub fn rocrand_set_quasi_random_generator_dimensions(
        generator: rocrand_generator,
        dimensions: ::std::os::raw::c_uint,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the version number of the library.\n\n Returns in \\p version the version number of the dynamically linked\n rocRAND library.\n\n \\param version - Version of the library\n\n \\return\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p version is NULL \\n\n - ROCRAND_STATUS_SUCCESS if the version number was successfully returned \\n"]
    pub fn rocrand_get_version(version: *mut ::std::os::raw::c_int) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Construct the histogram for a Poisson distribution.\n\n Construct the histogram for the Poisson distribution with lambda \\p lambda.\n\n \\param lambda - lambda for the Poisson distribution\n \\param discrete_distribution - pointer to the histogram in device memory\n\n \\return\n - ROCRAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p discrete_distribution pointer was null \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if lambda is non-positive \\n\n - ROCRAND_STATUS_SUCCESS if the histogram was constructed successfully \\n"]
    pub fn rocrand_create_poisson_distribution(
        lambda: f64,
        discrete_distribution: *mut rocrand_discrete_distribution,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Construct the histogram for a custom discrete distribution.\n\n Construct the histogram for the discrete distribution of \\p size\n 32-bit unsigned integers from the range [\\p offset, \\p offset + \\p size)\n using \\p probabilities as probabilities.\n\n \\param probabilities - probabilities of the the distribution in host memory\n \\param size - size of \\p probabilities\n \\param offset - offset of values\n \\param discrete_distribution - pointer to the histogram in device memory\n\n \\return\n - ROCRAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p discrete_distribution pointer was null \\n\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p size was zero \\n\n - ROCRAND_STATUS_SUCCESS if the histogram was constructed successfully \\n"]
    pub fn rocrand_create_discrete_distribution(
        probabilities: *const f64,
        size: ::std::os::raw::c_uint,
        offset: ::std::os::raw::c_uint,
        discrete_distribution: *mut rocrand_discrete_distribution,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Destroy the histogram array for a discrete distribution.\n\n Destroy the histogram array for a discrete distribution created by\n rocrand_create_poisson_distribution.\n\n \\param discrete_distribution - pointer to the histogram in device memory\n\n \\return\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p discrete_distribution was null \\n\n - ROCRAND_STATUS_SUCCESS if the histogram was destroyed successfully \\n"]
    pub fn rocrand_destroy_discrete_distribution(
        discrete_distribution: rocrand_discrete_distribution,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get the vector for 32-bit (scrambled-)sobol generation.\n\n \\param vectors - location where to write the vector pointer to\n\n \\param set - which direction vector set to use\n\n \\return\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p set was invalid for this method \\n\n - ROCRAND_STATUS_SUCCESS if the pointer was set succesfully \\n"]
    pub fn rocrand_get_direction_vectors32(
        vectors: *mut *const ::std::os::raw::c_uint,
        set: rocrand_direction_vector_set,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get the vector for 64-bit (scrambled-)sobol generation.\n\n \\param vectors - location where to write the vector pointer to\n\n \\param set - which direction vector set to use\n\n \\return\n - ROCRAND_STATUS_OUT_OF_RANGE if \\p set was invalid for this method \\n\n - ROCRAND_STATUS_SUCCESS if the pointer was set succesfully \\n"]
    pub fn rocrand_get_direction_vectors64(
        vectors: *mut *const ::std::os::raw::c_ulonglong,
        set: rocrand_direction_vector_set,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get the scramble constants for 32-bit scrambled sobol generation.\n\n \\param constants - location where to write the constants pointer to\n\n \\return\n - ROCRAND_STATUS_SUCCESS if the pointer was set succesfully \\n"]
    pub fn rocrand_get_scramble_constants32(
        constants: *mut *const ::std::os::raw::c_uint,
    ) -> rocrand_status;
}
unsafe extern "C" {
    #[doc = " \\brief Get the scramble constants for 64-bit scrambled sobol generation.\n\n \\param constants - location where to write the constants pointer to\n\n \\return\n - ROCRAND_STATUS_SUCCESS if the pointer was set succesfully \\n"]
    pub fn rocrand_get_scramble_constants64(
        constants: *mut *const ::std::os::raw::c_ulonglong,
    ) -> rocrand_status;
}
