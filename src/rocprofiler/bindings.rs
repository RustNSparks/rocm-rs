/* automatically generated by rust-bindgen 0.71.1 */

pub const ROCPROFILER_VERSION_MAJOR: u32 = 8;
pub const ROCPROFILER_VERSION_MINOR: u32 = 0;
#[doc = " The function has been executed successfully."]
pub const hsa_status_t_HSA_STATUS_SUCCESS: hsa_status_t = 0;
#[doc = " A traversal over a list of elements has been interrupted by the\n application before completing."]
pub const hsa_status_t_HSA_STATUS_INFO_BREAK: hsa_status_t = 1;
#[doc = " A generic error has occurred."]
pub const hsa_status_t_HSA_STATUS_ERROR: hsa_status_t = 4096;
#[doc = " One of the actual arguments does not meet a precondition stated in the\n documentation of the corresponding formal argument."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_ARGUMENT: hsa_status_t = 4097;
#[doc = " The requested queue creation is not valid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_QUEUE_CREATION: hsa_status_t = 4098;
#[doc = " The requested allocation is not valid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_ALLOCATION: hsa_status_t = 4099;
#[doc = " The agent is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_AGENT: hsa_status_t = 4100;
#[doc = " The memory region is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_REGION: hsa_status_t = 4101;
#[doc = " The signal is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_SIGNAL: hsa_status_t = 4102;
#[doc = " The queue is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_QUEUE: hsa_status_t = 4103;
#[doc = " The HSA runtime failed to allocate the necessary resources. This error\n may also occur when the HSA runtime needs to spawn threads or create\n internal OS-specific events."]
pub const hsa_status_t_HSA_STATUS_ERROR_OUT_OF_RESOURCES: hsa_status_t = 4104;
#[doc = " The AQL packet is malformed."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_PACKET_FORMAT: hsa_status_t = 4105;
#[doc = " An error has been detected while releasing a resource."]
pub const hsa_status_t_HSA_STATUS_ERROR_RESOURCE_FREE: hsa_status_t = 4106;
#[doc = " An API other than ::hsa_init has been invoked while the reference count\n of the HSA runtime is 0."]
pub const hsa_status_t_HSA_STATUS_ERROR_NOT_INITIALIZED: hsa_status_t = 4107;
#[doc = " The maximum reference count for the object has been reached."]
pub const hsa_status_t_HSA_STATUS_ERROR_REFCOUNT_OVERFLOW: hsa_status_t = 4108;
#[doc = " The arguments passed to a functions are not compatible."]
pub const hsa_status_t_HSA_STATUS_ERROR_INCOMPATIBLE_ARGUMENTS: hsa_status_t = 4109;
#[doc = " The index is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_INDEX: hsa_status_t = 4110;
#[doc = " The instruction set architecture is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_ISA: hsa_status_t = 4111;
#[doc = " The instruction set architecture name is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_ISA_NAME: hsa_status_t = 4119;
#[doc = " The code object is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_CODE_OBJECT: hsa_status_t = 4112;
#[doc = " The executable is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_EXECUTABLE: hsa_status_t = 4113;
#[doc = " The executable is frozen."]
pub const hsa_status_t_HSA_STATUS_ERROR_FROZEN_EXECUTABLE: hsa_status_t = 4114;
#[doc = " There is no symbol with the given name."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_SYMBOL_NAME: hsa_status_t = 4115;
#[doc = " The variable is already defined."]
pub const hsa_status_t_HSA_STATUS_ERROR_VARIABLE_ALREADY_DEFINED: hsa_status_t = 4116;
#[doc = " The variable is undefined."]
pub const hsa_status_t_HSA_STATUS_ERROR_VARIABLE_UNDEFINED: hsa_status_t = 4117;
#[doc = " An HSAIL operation resulted in a hardware exception."]
pub const hsa_status_t_HSA_STATUS_ERROR_EXCEPTION: hsa_status_t = 4118;
#[doc = " The code object symbol is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_CODE_SYMBOL: hsa_status_t = 4120;
#[doc = " The executable symbol is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_EXECUTABLE_SYMBOL: hsa_status_t = 4121;
#[doc = " The file descriptor is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_FILE: hsa_status_t = 4128;
#[doc = " The code object reader is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_CODE_OBJECT_READER: hsa_status_t = 4129;
#[doc = " The cache is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_CACHE: hsa_status_t = 4130;
#[doc = " The wavefront is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_WAVEFRONT: hsa_status_t = 4131;
#[doc = " The signal group is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_SIGNAL_GROUP: hsa_status_t = 4132;
#[doc = " The HSA runtime is not in the configuration state."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_RUNTIME_STATE: hsa_status_t = 4133;
#[doc = " The queue received an error that may require process termination."]
pub const hsa_status_t_HSA_STATUS_ERROR_FATAL: hsa_status_t = 4134;
#[doc = " @brief Status codes."]
pub type hsa_status_t = ::std::os::raw::c_uint;
#[doc = " @brief Struct containing an opaque handle to an agent, a device that participates in\n the HSA memory model. An agent can submit AQL packets for execution, and\n may also accept AQL packets for execution (agent dispatch packets or kernel\n dispatch packets launching HSAIL-derived binaries)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_agent_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[doc = " @brief Struct containing an opaque handle to an agent, a device that participates in\n the HSA memory model. An agent can submit AQL packets for execution, and\n may also accept AQL packets for execution (agent dispatch packets or kernel\n dispatch packets launching HSAIL-derived binaries)."]
pub type hsa_agent_t = hsa_agent_s;
#[doc = " CPU device."]
pub const hsa_device_type_t_HSA_DEVICE_TYPE_CPU: hsa_device_type_t = 0;
#[doc = " GPU device."]
pub const hsa_device_type_t_HSA_DEVICE_TYPE_GPU: hsa_device_type_t = 1;
#[doc = " DSP device."]
pub const hsa_device_type_t_HSA_DEVICE_TYPE_DSP: hsa_device_type_t = 2;
#[doc = " AI Engine (AIE) device."]
pub const hsa_device_type_t_HSA_DEVICE_TYPE_AIE: hsa_device_type_t = 3;
#[doc = " @brief Hardware device type."]
pub type hsa_device_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Signal handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_signal_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal. The value 0 is reserved."]
    pub handle: u64,
}
#[doc = " @brief Signal handle."]
pub type hsa_signal_t = hsa_signal_s;
#[doc = " @brief A fixed-size type used to represent ::hsa_queue_type_t constants."]
pub type hsa_queue_type32_t = u32;
#[doc = " @brief User mode queue.\n\n @details The queue structure is read-only and allocated by the HSA runtime,\n but agents can directly modify the contents of the buffer pointed by @a\n base_address, or use HSA runtime APIs to access the doorbell signal.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_queue_s {
    #[doc = " Queue type."]
    pub type_: hsa_queue_type32_t,
    #[doc = " Queue features mask. This is a bit-field of ::hsa_queue_feature_t\n values. Applications should ignore any unknown set bits."]
    pub features: u32,
    pub base_address: *mut ::std::os::raw::c_void,
    #[doc = " Signal object used by the application to indicate the ID of a packet that\n is ready to be processed. The HSA runtime manages the doorbell signal. If\n the application tries to replace or destroy this signal, the behavior is\n undefined.\n\n If @a type is ::HSA_QUEUE_TYPE_SINGLE, the doorbell signal value must be\n updated in a monotonically increasing fashion. If @a type is\n ::HSA_QUEUE_TYPE_MULTI, the doorbell signal value can be updated with any\n value."]
    pub doorbell_signal: hsa_signal_t,
    #[doc = " Maximum number of packets the queue can hold. Must be a power of 2."]
    pub size: u32,
    #[doc = " Reserved. Must be 0."]
    pub reserved1: u32,
    #[doc = " Queue identifier, which is unique over the lifetime of the application."]
    pub id: u64,
}
#[doc = " @brief User mode queue.\n\n @details The queue structure is read-only and allocated by the HSA runtime,\n but agents can directly modify the contents of the buffer pointed by @a\n base_address, or use HSA runtime APIs to access the doorbell signal.\n"]
pub type hsa_queue_t = hsa_queue_s;
#[doc = " @brief AQL kernel dispatch packet"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_kernel_dispatch_packet_s {
    #[doc = " Packet header. Used to configure multiple packet parameters such as the\n packet type. The parameters are described by ::hsa_packet_header_t."]
    pub header: u16,
    #[doc = " Dispatch setup parameters. Used to configure kernel dispatch parameters\n such as the number of dimensions in the grid. The parameters are described\n by ::hsa_kernel_dispatch_packet_setup_t."]
    pub setup: u16,
    #[doc = " X dimension of work-group, in work-items. Must be greater than 0."]
    pub workgroup_size_x: u16,
    #[doc = " Y dimension of work-group, in work-items. Must be greater than\n 0. If the grid has 1 dimension, the only valid value is 1."]
    pub workgroup_size_y: u16,
    #[doc = " Z dimension of work-group, in work-items. Must be greater than\n 0. If the grid has 1 or 2 dimensions, the only valid value is 1."]
    pub workgroup_size_z: u16,
    #[doc = " Reserved. Must be 0."]
    pub reserved0: u16,
    #[doc = " X dimension of grid, in work-items. Must be greater than 0. Must\n not be smaller than @a workgroup_size_x."]
    pub grid_size_x: u32,
    #[doc = " Y dimension of grid, in work-items. Must be greater than 0. If the grid has\n 1 dimension, the only valid value is 1. Must not be smaller than @a\n workgroup_size_y."]
    pub grid_size_y: u32,
    #[doc = " Z dimension of grid, in work-items. Must be greater than 0. If the grid has\n 1 or 2 dimensions, the only valid value is 1. Must not be smaller than @a\n workgroup_size_z."]
    pub grid_size_z: u32,
    #[doc = " Size in bytes of private memory allocation request (per work-item)."]
    pub private_segment_size: u32,
    #[doc = " Size in bytes of group memory allocation request (per work-group). Must not\n be less than the sum of the group memory used by the kernel (and the\n functions it calls directly or indirectly) and the dynamically allocated\n group segment variables."]
    pub group_segment_size: u32,
    #[doc = " Opaque handle to a code object that includes an implementation-defined\n executable code for the kernel."]
    pub kernel_object: u64,
    pub kernarg_address: *mut ::std::os::raw::c_void,
    #[doc = " Reserved. Must be 0."]
    pub reserved2: u64,
    #[doc = " Signal used to indicate completion of the job. The application can use the\n special signal handle 0 to indicate that no signal is used."]
    pub completion_signal: hsa_signal_t,
}
#[doc = " @brief AQL kernel dispatch packet"]
pub type hsa_kernel_dispatch_packet_t = hsa_kernel_dispatch_packet_s;
pub type amd_kernel_code_version32_t = u32;
pub type amd_machine_kind16_t = u16;
pub type amd_machine_version16_t = u16;
pub type amd_compute_pgm_rsrc_one32_t = u32;
pub type amd_compute_pgm_rsrc_two32_t = u32;
pub type amd_kernel_code_properties32_t = u32;
pub type amd_powertwo8_t = u8;
pub type amd_enabled_control_directive64_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amd_control_directives_s {
    pub enabled_control_directives: amd_enabled_control_directive64_t,
    pub enable_break_exceptions: u16,
    pub enable_detect_exceptions: u16,
    pub max_dynamic_group_size: u32,
    pub max_flat_grid_size: u64,
    pub max_flat_workgroup_size: u32,
    pub required_dim: u8,
    pub reserved1: [u8; 3usize],
    pub required_grid_size: [u64; 3usize],
    pub required_workgroup_size: [u32; 3usize],
    pub reserved2: [u8; 60usize],
}
pub type amd_control_directives_t = amd_control_directives_s;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct amd_kernel_code_s {
    pub amd_kernel_code_version_major: amd_kernel_code_version32_t,
    pub amd_kernel_code_version_minor: amd_kernel_code_version32_t,
    pub amd_machine_kind: amd_machine_kind16_t,
    pub amd_machine_version_major: amd_machine_version16_t,
    pub amd_machine_version_minor: amd_machine_version16_t,
    pub amd_machine_version_stepping: amd_machine_version16_t,
    pub kernel_code_entry_byte_offset: i64,
    pub kernel_code_prefetch_byte_offset: i64,
    pub kernel_code_prefetch_byte_size: u64,
    pub max_scratch_backing_memory_byte_size: u64,
    pub compute_pgm_rsrc1: amd_compute_pgm_rsrc_one32_t,
    pub compute_pgm_rsrc2: amd_compute_pgm_rsrc_two32_t,
    pub kernel_code_properties: amd_kernel_code_properties32_t,
    pub workitem_private_segment_byte_size: u32,
    pub workgroup_group_segment_byte_size: u32,
    pub gds_segment_byte_size: u32,
    pub kernarg_segment_byte_size: u64,
    pub workgroup_fbarrier_count: u32,
    pub wavefront_sgpr_count: u16,
    pub workitem_vgpr_count: u16,
    pub reserved_vgpr_first: u16,
    pub reserved_vgpr_count: u16,
    pub reserved_sgpr_first: u16,
    pub reserved_sgpr_count: u16,
    pub debug_wavefront_private_segment_offset_sgpr: u16,
    pub debug_private_segment_buffer_sgpr: u16,
    pub kernarg_segment_alignment: amd_powertwo8_t,
    pub group_segment_alignment: amd_powertwo8_t,
    pub private_segment_alignment: amd_powertwo8_t,
    pub wavefront_size: amd_powertwo8_t,
    pub call_convention: i32,
    pub reserved1: [u8; 12usize],
    pub runtime_loader_kernel_symbol: u64,
    pub control_directives: amd_control_directives_t,
}
pub type amd_kernel_code_t = amd_kernel_code_s;
#[doc = " Global segment. Used to hold data that is shared by all agents."]
pub const hsa_amd_segment_t_HSA_AMD_SEGMENT_GLOBAL: hsa_amd_segment_t = 0;
#[doc = " Read-only segment. Used to hold data that remains constant during the\n execution of a kernel."]
pub const hsa_amd_segment_t_HSA_AMD_SEGMENT_READONLY: hsa_amd_segment_t = 1;
#[doc = " Private segment. Used to hold data that is local to a single work-item."]
pub const hsa_amd_segment_t_HSA_AMD_SEGMENT_PRIVATE: hsa_amd_segment_t = 2;
#[doc = " Group segment. Used to hold data that is shared by the work-items of a\n work-group."]
pub const hsa_amd_segment_t_HSA_AMD_SEGMENT_GROUP: hsa_amd_segment_t = 3;
#[doc = " @brief Memory segments associated with a memory pool."]
pub type hsa_amd_segment_t = ::std::os::raw::c_uint;
#[doc = " The application can use allocations in the memory pool to store kernel\n arguments, and provide the values for the kernarg segment of\n a kernel dispatch."]
pub const hsa_amd_memory_pool_global_flag_s_HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT:
    hsa_amd_memory_pool_global_flag_s = 1;
#[doc = " Updates to memory in this pool conform to HSA memory consistency model.\n If this flag is set, then ::HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_COARSE_GRAINED\n must not be set."]
pub const hsa_amd_memory_pool_global_flag_s_HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_FINE_GRAINED:
    hsa_amd_memory_pool_global_flag_s = 2;
#[doc = " Writes to memory in this pool can be performed by a single agent at a time."]
pub const hsa_amd_memory_pool_global_flag_s_HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_COARSE_GRAINED:
    hsa_amd_memory_pool_global_flag_s = 4;
#[doc = " Updates to memory in this memory pool have extended scope, acting as\n system-scope atomics for variables in memory regions of this type.\n Note: On non-compliant systems, device-specific actions may be required\n for system-scope coherence."]
pub const hsa_amd_memory_pool_global_flag_s_HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_EXTENDED_SCOPE_FINE_GRAINED : hsa_amd_memory_pool_global_flag_s = 8 ;
pub type hsa_amd_memory_pool_global_flag_s = ::std::os::raw::c_uint;
pub use self::hsa_amd_memory_pool_global_flag_s as hsa_amd_memory_pool_global_flag_t;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_CPC:
    hsa_ven_amd_aqlprofile_block_name_t = 0;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_CPF:
    hsa_ven_amd_aqlprofile_block_name_t = 1;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_GDS:
    hsa_ven_amd_aqlprofile_block_name_t = 2;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_GRBM:
    hsa_ven_amd_aqlprofile_block_name_t = 3;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_GRBMSE:
    hsa_ven_amd_aqlprofile_block_name_t = 4;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_SPI:
    hsa_ven_amd_aqlprofile_block_name_t = 5;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_SQ:
    hsa_ven_amd_aqlprofile_block_name_t = 6;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_SQCS:
    hsa_ven_amd_aqlprofile_block_name_t = 7;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_SRBM:
    hsa_ven_amd_aqlprofile_block_name_t = 8;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_SX:
    hsa_ven_amd_aqlprofile_block_name_t = 9;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_TA:
    hsa_ven_amd_aqlprofile_block_name_t = 10;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_TCA:
    hsa_ven_amd_aqlprofile_block_name_t = 11;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_TCC:
    hsa_ven_amd_aqlprofile_block_name_t = 12;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_TCP:
    hsa_ven_amd_aqlprofile_block_name_t = 13;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_TD:
    hsa_ven_amd_aqlprofile_block_name_t = 14;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_MCARB:
    hsa_ven_amd_aqlprofile_block_name_t = 15;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_MCHUB:
    hsa_ven_amd_aqlprofile_block_name_t = 16;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_MCMCBVM:
    hsa_ven_amd_aqlprofile_block_name_t = 17;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_MCSEQ:
    hsa_ven_amd_aqlprofile_block_name_t = 18;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_MCVML2:
    hsa_ven_amd_aqlprofile_block_name_t = 19;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_MCXBAR:
    hsa_ven_amd_aqlprofile_block_name_t = 20;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_ATC:
    hsa_ven_amd_aqlprofile_block_name_t = 21;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_ATCL2:
    hsa_ven_amd_aqlprofile_block_name_t = 22;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_GCEA:
    hsa_ven_amd_aqlprofile_block_name_t = 23;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_RPB:
    hsa_ven_amd_aqlprofile_block_name_t = 24;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_SDMA:
    hsa_ven_amd_aqlprofile_block_name_t = 25;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_GL1A:
    hsa_ven_amd_aqlprofile_block_name_t = 26;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_GL1C:
    hsa_ven_amd_aqlprofile_block_name_t = 27;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_GL2A:
    hsa_ven_amd_aqlprofile_block_name_t = 28;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_GL2C:
    hsa_ven_amd_aqlprofile_block_name_t = 29;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_GCR:
    hsa_ven_amd_aqlprofile_block_name_t = 30;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_GUS:
    hsa_ven_amd_aqlprofile_block_name_t = 31;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_UMC:
    hsa_ven_amd_aqlprofile_block_name_t = 32;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCK_NAME_MMEA:
    hsa_ven_amd_aqlprofile_block_name_t = 33;
pub const hsa_ven_amd_aqlprofile_block_name_t_HSA_VEN_AMD_AQLPROFILE_BLOCKS_NUMBER:
    hsa_ven_amd_aqlprofile_block_name_t = 34;
pub type hsa_ven_amd_aqlprofile_block_name_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ven_amd_aqlprofile_event_t {
    pub block_name: hsa_ven_amd_aqlprofile_block_name_t,
    pub block_index: u32,
    pub counter_id: u32,
}
#[doc = " Select the target compute unit (wgp) for profiling."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_COMPUTE_UNIT_TARGET : hsa_ven_amd_aqlprofile_parameter_name_t = 0 ;
#[doc = " VMID Mask"]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_VM_ID_MASK : hsa_ven_amd_aqlprofile_parameter_name_t = 1 ;
#[doc = " Legacy. Deprecated."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_MASK:
    hsa_ven_amd_aqlprofile_parameter_name_t = 2;
#[doc = " Legacy. Deprecated."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_TOKEN_MASK : hsa_ven_amd_aqlprofile_parameter_name_t = 3 ;
#[doc = " Legacy. Deprecated."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_TOKEN_MASK2 : hsa_ven_amd_aqlprofile_parameter_name_t = 4 ;
#[doc = " Shader engine mask for selection."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_SE_MASK:
    hsa_ven_amd_aqlprofile_parameter_name_t = 5;
#[doc = " Legacy. Deprecated."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_SAMPLE_RATE : hsa_ven_amd_aqlprofile_parameter_name_t = 6 ;
#[doc = " Legacy. Deprecated."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_K_CONCURRENT : hsa_ven_amd_aqlprofile_parameter_name_t = 7 ;
#[doc = " Set SIMD Mask (GFX9) or SIMD ID for collection (Navi)"]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_SIMD_SELECTION : hsa_ven_amd_aqlprofile_parameter_name_t = 8 ;
#[doc = " Set true for occupancy collection only."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_OCCUPANCY_MODE : hsa_ven_amd_aqlprofile_parameter_name_t = 9 ;
#[doc = " ATT collection max data size, in MB. Shared among shader engines."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_ATT_BUFFER_SIZE : hsa_ven_amd_aqlprofile_parameter_name_t = 10 ;
#[doc = " Mask of which compute units to generate perfcounters. GFX9 only."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_PERFCOUNTER_MASK : hsa_ven_amd_aqlprofile_parameter_name_t = 240 ;
#[doc = " Select collection period for perfcounters. GFX9 only."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_PERFCOUNTER_CTRL : hsa_ven_amd_aqlprofile_parameter_name_t = 241 ;
#[doc = " Select perfcounter ID (SQ block) for collection. GFX9 only."]
pub const hsa_ven_amd_aqlprofile_parameter_name_t_HSA_VEN_AMD_AQLPROFILE_PARAMETER_NAME_PERFCOUNTER_NAME : hsa_ven_amd_aqlprofile_parameter_name_t = 242 ;
pub type hsa_ven_amd_aqlprofile_parameter_name_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ven_amd_aqlprofile_parameter_t {
    pub parameter_name: hsa_ven_amd_aqlprofile_parameter_name_t,
    pub value: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ven_amd_aqlprofile_descriptor_t {
    pub ptr: *mut ::std::os::raw::c_void,
    pub size: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hsa_ven_amd_aqlprofile_info_data_t {
    pub sample_id: u32,
    pub __bindgen_anon_1: hsa_ven_amd_aqlprofile_info_data_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hsa_ven_amd_aqlprofile_info_data_t__bindgen_ty_1 {
    pub pmc_data: hsa_ven_amd_aqlprofile_info_data_t__bindgen_ty_1__bindgen_ty_1,
    pub trace_data: hsa_ven_amd_aqlprofile_descriptor_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ven_amd_aqlprofile_info_data_t__bindgen_ty_1__bindgen_ty_1 {
    pub event: hsa_ven_amd_aqlprofile_event_t,
    pub result: u64,
}
pub const hsa_ven_amd_aqlprofile_info_type_t_HSA_VEN_AMD_AQLPROFILE_INFO_COMMAND_BUFFER_SIZE:
    hsa_ven_amd_aqlprofile_info_type_t = 0;
pub const hsa_ven_amd_aqlprofile_info_type_t_HSA_VEN_AMD_AQLPROFILE_INFO_PMC_DATA_SIZE:
    hsa_ven_amd_aqlprofile_info_type_t = 1;
pub const hsa_ven_amd_aqlprofile_info_type_t_HSA_VEN_AMD_AQLPROFILE_INFO_PMC_DATA:
    hsa_ven_amd_aqlprofile_info_type_t = 2;
pub const hsa_ven_amd_aqlprofile_info_type_t_HSA_VEN_AMD_AQLPROFILE_INFO_TRACE_DATA:
    hsa_ven_amd_aqlprofile_info_type_t = 3;
pub const hsa_ven_amd_aqlprofile_info_type_t_HSA_VEN_AMD_AQLPROFILE_INFO_BLOCK_COUNTERS:
    hsa_ven_amd_aqlprofile_info_type_t = 4;
pub const hsa_ven_amd_aqlprofile_info_type_t_HSA_VEN_AMD_AQLPROFILE_INFO_BLOCK_ID:
    hsa_ven_amd_aqlprofile_info_type_t = 5;
pub const hsa_ven_amd_aqlprofile_info_type_t_HSA_VEN_AMD_AQLPROFILE_INFO_ENABLE_CMD:
    hsa_ven_amd_aqlprofile_info_type_t = 6;
pub const hsa_ven_amd_aqlprofile_info_type_t_HSA_VEN_AMD_AQLPROFILE_INFO_DISABLE_CMD:
    hsa_ven_amd_aqlprofile_info_type_t = 7;
pub type hsa_ven_amd_aqlprofile_info_type_t = ::std::os::raw::c_uint;
pub type hsa_ven_amd_aqlprofile_data_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        info_type: hsa_ven_amd_aqlprofile_info_type_t,
        info_data: *mut hsa_ven_amd_aqlprofile_info_data_t,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t,
>;
unsafe extern "C" {
    pub fn rocprofiler_version_major() -> u32;
}
unsafe extern "C" {
    pub fn rocprofiler_version_minor() -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_settings_t {
    pub intercept_mode: u32,
    pub code_obj_tracking: u32,
    pub memcopy_tracking: u32,
    pub trace_size: u32,
    pub trace_local: u32,
    pub timeout: u64,
    pub timestamp_on: u32,
    pub hsa_intercepting: u32,
    pub k_concurrent: u32,
    pub opt_mode: u32,
    pub obj_dumping: u32,
}
unsafe extern "C" {
    pub fn rocprofiler_error_string(str_: *mut *const ::std::os::raw::c_char) -> hsa_status_t;
}
pub const rocprofiler_feature_kind_t_ROCPROFILER_FEATURE_KIND_METRIC: rocprofiler_feature_kind_t =
    0;
pub const rocprofiler_feature_kind_t_ROCPROFILER_FEATURE_KIND_TRACE: rocprofiler_feature_kind_t = 1;
pub const rocprofiler_feature_kind_t_ROCPROFILER_FEATURE_KIND_SPM_MOD: rocprofiler_feature_kind_t =
    2;
pub const rocprofiler_feature_kind_t_ROCPROFILER_FEATURE_KIND_PCSMP_MOD:
    rocprofiler_feature_kind_t = 4;
pub type rocprofiler_feature_kind_t = ::std::os::raw::c_uint;
pub type rocprofiler_parameter_t = hsa_ven_amd_aqlprofile_parameter_t;
pub const rocprofiler_data_kind_t_ROCPROFILER_DATA_KIND_UNINIT: rocprofiler_data_kind_t = 0;
pub const rocprofiler_data_kind_t_ROCPROFILER_DATA_KIND_INT32: rocprofiler_data_kind_t = 1;
pub const rocprofiler_data_kind_t_ROCPROFILER_DATA_KIND_INT64: rocprofiler_data_kind_t = 2;
pub const rocprofiler_data_kind_t_ROCPROFILER_DATA_KIND_FLOAT: rocprofiler_data_kind_t = 3;
pub const rocprofiler_data_kind_t_ROCPROFILER_DATA_KIND_DOUBLE: rocprofiler_data_kind_t = 4;
pub const rocprofiler_data_kind_t_ROCPROFILER_DATA_KIND_BYTES: rocprofiler_data_kind_t = 5;
pub type rocprofiler_data_kind_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocprofiler_data_t {
    pub kind: rocprofiler_data_kind_t,
    pub __bindgen_anon_1: rocprofiler_data_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rocprofiler_data_t__bindgen_ty_1 {
    pub result_int32: u32,
    pub result_int64: u64,
    pub result_float: f32,
    pub result_double: f64,
    pub result_bytes: rocprofiler_data_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_data_t__bindgen_ty_1__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_void,
    pub size: u32,
    pub instance_count: u32,
    pub copy: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocprofiler_feature_t {
    pub kind: rocprofiler_feature_kind_t,
    pub __bindgen_anon_1: rocprofiler_feature_t__bindgen_ty_1,
    pub parameters: *const rocprofiler_parameter_t,
    pub parameter_count: u32,
    pub data: rocprofiler_data_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rocprofiler_feature_t__bindgen_ty_1 {
    pub name: *const ::std::os::raw::c_char,
    pub counter: rocprofiler_feature_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_feature_t__bindgen_ty_1__bindgen_ty_1 {
    pub block: *const ::std::os::raw::c_char,
    pub event: u32,
}
pub type rocprofiler_feature_set_t = ::std::os::raw::c_void;
pub type rocprofiler_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_group_t {
    pub index: ::std::os::raw::c_uint,
    pub features: *mut *mut rocprofiler_feature_t,
    pub feature_count: u32,
    pub context: *mut rocprofiler_t,
}
pub const rocprofiler_mode_t_ROCPROFILER_MODE_STANDALONE: rocprofiler_mode_t = 1;
pub const rocprofiler_mode_t_ROCPROFILER_MODE_CREATEQUEUE: rocprofiler_mode_t = 2;
pub const rocprofiler_mode_t_ROCPROFILER_MODE_SINGLEGROUP: rocprofiler_mode_t = 4;
pub type rocprofiler_mode_t = ::std::os::raw::c_uint;
pub type rocprofiler_handler_t = ::std::option::Option<
    unsafe extern "C" fn(group: rocprofiler_group_t, arg: *mut ::std::os::raw::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_properties_t {
    pub queue: *mut hsa_queue_t,
    pub queue_depth: u32,
    pub handler: rocprofiler_handler_t,
    pub handler_arg: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    pub fn rocprofiler_open(
        agent: hsa_agent_t,
        features: *mut rocprofiler_feature_t,
        feature_count: u32,
        context: *mut *mut rocprofiler_t,
        mode: u32,
        properties: *mut rocprofiler_properties_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_add_feature(
        feature: *const rocprofiler_feature_t,
        features_set: *mut rocprofiler_feature_set_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_features_set_open(
        agent: hsa_agent_t,
        features_set: *mut rocprofiler_feature_set_t,
        context: *mut *mut rocprofiler_t,
        mode: u32,
        properties: *mut rocprofiler_properties_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_close(context: *mut rocprofiler_t) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_reset(context: *mut rocprofiler_t, group_index: u32) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_get_agent(
        context: *mut rocprofiler_t,
        agent: *mut hsa_agent_t,
    ) -> hsa_status_t;
}
pub const rocprofiler_time_id_t_ROCPROFILER_TIME_ID_CLOCK_REALTIME: rocprofiler_time_id_t = 0;
pub const rocprofiler_time_id_t_ROCPROFILER_TIME_ID_CLOCK_REALTIME_COARSE: rocprofiler_time_id_t =
    1;
pub const rocprofiler_time_id_t_ROCPROFILER_TIME_ID_CLOCK_MONOTONIC: rocprofiler_time_id_t = 2;
pub const rocprofiler_time_id_t_ROCPROFILER_TIME_ID_CLOCK_MONOTONIC_COARSE: rocprofiler_time_id_t =
    3;
pub const rocprofiler_time_id_t_ROCPROFILER_TIME_ID_CLOCK_MONOTONIC_RAW: rocprofiler_time_id_t = 4;
pub type rocprofiler_time_id_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn rocprofiler_get_time(
        time_id: rocprofiler_time_id_t,
        timestamp: u64,
        value_ns: *mut u64,
        error_ns: *mut u64,
    ) -> hsa_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_dispatch_record_t {
    pub dispatch: u64,
    pub begin: u64,
    pub end: u64,
    pub complete: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_callback_data_t {
    pub agent: hsa_agent_t,
    pub agent_index: u32,
    pub queue: *const hsa_queue_t,
    pub queue_index: u64,
    pub queue_id: u32,
    pub completion_signal: hsa_signal_t,
    pub packet: *const hsa_kernel_dispatch_packet_t,
    pub kernel_name: *const ::std::os::raw::c_char,
    pub kernel_object: u64,
    pub kernel_code: *const amd_kernel_code_t,
    pub thread_id: u32,
    pub record: *const rocprofiler_dispatch_record_t,
}
pub type rocprofiler_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        callback_data: *const rocprofiler_callback_data_t,
        user_data: *mut ::std::os::raw::c_void,
        group: *mut rocprofiler_group_t,
    ) -> hsa_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_queue_callbacks_t {
    pub dispatch: rocprofiler_callback_t,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut hsa_queue_t,
            data: *mut ::std::os::raw::c_void,
        ) -> hsa_status_t,
    >,
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(
            queue: *mut hsa_queue_t,
            data: *mut ::std::os::raw::c_void,
        ) -> hsa_status_t,
    >,
}
unsafe extern "C" {
    pub fn rocprofiler_set_queue_callbacks(
        callbacks: rocprofiler_queue_callbacks_t,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_remove_queue_callbacks() -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_start_queue_callbacks() -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_stop_queue_callbacks() -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_start(context: *mut rocprofiler_t, group_index: u32) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_stop(context: *mut rocprofiler_t, group_index: u32) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_read(context: *mut rocprofiler_t, group_index: u32) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_get_data(context: *mut rocprofiler_t, group_index: u32) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_group_count(
        context: *const rocprofiler_t,
        group_count: *mut u32,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_get_group(
        context: *mut rocprofiler_t,
        group_index: u32,
        group: *mut rocprofiler_group_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_group_start(group: *mut rocprofiler_group_t) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_group_stop(group: *mut rocprofiler_group_t) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_group_read(group: *mut rocprofiler_group_t) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_group_get_data(group: *mut rocprofiler_group_t) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_get_metrics(context: *const rocprofiler_t) -> hsa_status_t;
}
pub type rocprofiler_trace_data_callback_t = hsa_ven_amd_aqlprofile_data_callback_t;
unsafe extern "C" {
    pub fn rocprofiler_iterate_trace_data(
        context: *mut rocprofiler_t,
        callback: rocprofiler_trace_data_callback_t,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
pub const rocprofiler_info_kind_t_ROCPROFILER_INFO_KIND_METRIC: rocprofiler_info_kind_t = 0;
pub const rocprofiler_info_kind_t_ROCPROFILER_INFO_KIND_METRIC_COUNT: rocprofiler_info_kind_t = 1;
pub const rocprofiler_info_kind_t_ROCPROFILER_INFO_KIND_TRACE: rocprofiler_info_kind_t = 2;
pub const rocprofiler_info_kind_t_ROCPROFILER_INFO_KIND_TRACE_COUNT: rocprofiler_info_kind_t = 3;
pub const rocprofiler_info_kind_t_ROCPROFILER_INFO_KIND_TRACE_PARAMETER: rocprofiler_info_kind_t =
    4;
pub const rocprofiler_info_kind_t_ROCPROFILER_INFO_KIND_TRACE_PARAMETER_COUNT:
    rocprofiler_info_kind_t = 5;
pub type rocprofiler_info_kind_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union rocprofiler_info_query_t {
    pub info_kind: rocprofiler_info_kind_t,
    pub trace_parameter: rocprofiler_info_query_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_info_query_t__bindgen_ty_1 {
    pub trace_name: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocprofiler_info_data_t {
    pub agent_index: u32,
    pub kind: rocprofiler_info_kind_t,
    pub __bindgen_anon_1: rocprofiler_info_data_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rocprofiler_info_data_t__bindgen_ty_1 {
    pub metric: rocprofiler_info_data_t__bindgen_ty_1__bindgen_ty_1,
    pub trace: rocprofiler_info_data_t__bindgen_ty_1__bindgen_ty_2,
    pub trace_parameter: rocprofiler_info_data_t__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_info_data_t__bindgen_ty_1__bindgen_ty_1 {
    pub name: *const ::std::os::raw::c_char,
    pub instances: u32,
    pub expr: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub block_name: *const ::std::os::raw::c_char,
    pub block_counters: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_info_data_t__bindgen_ty_1__bindgen_ty_2 {
    pub name: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub parameter_count: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_info_data_t__bindgen_ty_1__bindgen_ty_3 {
    pub code: u32,
    pub trace_name: *const ::std::os::raw::c_char,
    pub parameter_name: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
}
unsafe extern "C" {
    pub fn rocprofiler_get_info(
        agent: *const hsa_agent_t,
        kind: rocprofiler_info_kind_t,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_iterate_info(
        agent: *const hsa_agent_t,
        kind: rocprofiler_info_kind_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                info: rocprofiler_info_data_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_query_info(
        agent: *const hsa_agent_t,
        query: rocprofiler_info_query_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                info: rocprofiler_info_data_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_queue_create_profiled(
        agent_handle: hsa_agent_t,
        size: u32,
        type_: hsa_queue_type32_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                status: hsa_status_t,
                source: *mut hsa_queue_t,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
        data: *mut ::std::os::raw::c_void,
        private_segment_size: u32,
        group_segment_size: u32,
        queue: *mut *mut hsa_queue_t,
    ) -> hsa_status_t;
}
pub type rocprofiler_pool_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_pool_entry_t {
    pub context: *mut rocprofiler_t,
    pub payload: *mut ::std::os::raw::c_void,
}
pub type rocprofiler_pool_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        entry: *const rocprofiler_pool_entry_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_pool_properties_t {
    pub num_entries: u32,
    pub payload_bytes: u32,
    pub handler: rocprofiler_pool_handler_t,
    pub handler_arg: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    pub fn rocprofiler_pool_open(
        agent: hsa_agent_t,
        features: *mut rocprofiler_feature_t,
        feature_count: u32,
        pool: *mut *mut rocprofiler_pool_t,
        mode: u32,
        arg1: *mut rocprofiler_pool_properties_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_pool_close(pool: *mut rocprofiler_pool_t) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_pool_fetch(
        pool: *mut rocprofiler_pool_t,
        entry: *mut rocprofiler_pool_entry_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_pool_release(entry: *mut rocprofiler_pool_entry_t) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_pool_iterate(
        pool: *mut rocprofiler_pool_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                entry: *mut rocprofiler_pool_entry_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    pub fn rocprofiler_pool_flush(pool: *mut rocprofiler_pool_t) -> hsa_status_t;
}
pub const rocprofiler_hsa_cb_id_t_ROCPROFILER_HSA_CB_ID_ALLOCATE: rocprofiler_hsa_cb_id_t = 0;
pub const rocprofiler_hsa_cb_id_t_ROCPROFILER_HSA_CB_ID_DEVICE: rocprofiler_hsa_cb_id_t = 1;
pub const rocprofiler_hsa_cb_id_t_ROCPROFILER_HSA_CB_ID_MEMCOPY: rocprofiler_hsa_cb_id_t = 2;
pub const rocprofiler_hsa_cb_id_t_ROCPROFILER_HSA_CB_ID_SUBMIT: rocprofiler_hsa_cb_id_t = 3;
pub const rocprofiler_hsa_cb_id_t_ROCPROFILER_HSA_CB_ID_KSYMBOL: rocprofiler_hsa_cb_id_t = 4;
pub const rocprofiler_hsa_cb_id_t_ROCPROFILER_HSA_CB_ID_CODEOBJ: rocprofiler_hsa_cb_id_t = 5;
pub type rocprofiler_hsa_cb_id_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocprofiler_hsa_callback_data_t {
    pub __bindgen_anon_1: rocprofiler_hsa_callback_data_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rocprofiler_hsa_callback_data_t__bindgen_ty_1 {
    pub allocate: rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_1,
    pub device: rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_2,
    pub memcopy: rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_3,
    pub submit: rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_4,
    pub ksymbol: rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_5,
    pub codeobj: rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_1 {
    pub ptr: *const ::std::os::raw::c_void,
    pub size: usize,
    pub segment: hsa_amd_segment_t,
    pub global_flag: hsa_amd_memory_pool_global_flag_t,
    pub is_code: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_2 {
    pub type_: hsa_device_type_t,
    pub id: u32,
    pub agent: hsa_agent_t,
    pub ptr: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_3 {
    pub dst: *const ::std::os::raw::c_void,
    pub src: *const ::std::os::raw::c_void,
    pub size: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_4 {
    pub packet: *const ::std::os::raw::c_void,
    pub kernel_name: *const ::std::os::raw::c_char,
    pub queue: *mut hsa_queue_t,
    pub device_type: u32,
    pub device_id: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_5 {
    pub object: u64,
    pub name: *const ::std::os::raw::c_char,
    pub name_length: u32,
    pub unload: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_hsa_callback_data_t__bindgen_ty_1__bindgen_ty_6 {
    pub storage_type: u32,
    pub storage_file: ::std::os::raw::c_int,
    pub memory_base: u64,
    pub memory_size: u64,
    pub load_base: u64,
    pub load_size: u64,
    pub load_delta: u64,
    pub uri_length: u32,
    pub uri: *mut ::std::os::raw::c_char,
    pub unload: ::std::os::raw::c_int,
}
pub type rocprofiler_hsa_callback_fun_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: rocprofiler_hsa_cb_id_t,
        data: *const rocprofiler_hsa_callback_data_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rocprofiler_hsa_callbacks_t {
    pub allocate: rocprofiler_hsa_callback_fun_t,
    pub device: rocprofiler_hsa_callback_fun_t,
    pub memcopy: rocprofiler_hsa_callback_fun_t,
    pub submit: rocprofiler_hsa_callback_fun_t,
    pub ksymbol: rocprofiler_hsa_callback_fun_t,
    pub codeobj: rocprofiler_hsa_callback_fun_t,
}
unsafe extern "C" {
    pub fn rocprofiler_set_hsa_callbacks(
        callbacks: rocprofiler_hsa_callbacks_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
pub const hsa_evt_id_t_HSA_EVT_ID_ALLOCATE: hsa_evt_id_t = 0;
pub const hsa_evt_id_t_HSA_EVT_ID_DEVICE: hsa_evt_id_t = 1;
pub const hsa_evt_id_t_HSA_EVT_ID_MEMCOPY: hsa_evt_id_t = 2;
pub const hsa_evt_id_t_HSA_EVT_ID_SUBMIT: hsa_evt_id_t = 3;
pub const hsa_evt_id_t_HSA_EVT_ID_KSYMBOL: hsa_evt_id_t = 4;
pub const hsa_evt_id_t_HSA_EVT_ID_CODEOBJ: hsa_evt_id_t = 5;
pub const hsa_evt_id_t_HSA_EVT_ID_NUMBER: hsa_evt_id_t = 6;
pub type hsa_evt_id_t = ::std::os::raw::c_uint;
pub type hsa_evt_data_t = rocprofiler_hsa_callback_data_t;
