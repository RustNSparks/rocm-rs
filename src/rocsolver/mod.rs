//! Safe Rust wrappers for rocSOLVER - AMD's LAPACK implementation for ROCm.
//!
//! rocSOLVER provides GPU-accelerated implementations of LAPACK routines for
//! linear algebra operations. This module provides safe, ergonomic Rust wrappers
//! around the underlying C API.
//!
//! # Architecture
//!
//! This module reuses the [`Handle`] from [`crate::rocblas`] since rocSOLVER
//! internally uses rocBLAS handles. This enables seamless interoperability
//! between rocBLAS and rocSOLVER operations.
//!
//! # Module Organization
//!
//! - [`error`] - Error handling types
//! - [`types`] - Type-safe enums for rocSOLVER parameters
//! - [`ffi`] - Raw FFI bindings (for advanced use)
//! - [`lapack`] - LAPACK-style linear algebra operations
//!
//! # Supported Operations
//!
//! ## Matrix Factorizations ([`lapack::decompositions`])
//! - [`geqrf`] - QR factorization
//! - [`getrf`] - LU factorization with partial pivoting
//! - [`potrf`] - Cholesky factorization for symmetric positive definite matrices
//! - [`gebrd`] - Bidiagonal reduction
//!
//! ## Linear System Solvers ([`lapack::solvers`])
//! - [`gesv`] - Solve A*X=B using LU factorization
//! - [`getrs`] - Solve using pre-computed LU factors
//! - [`posv`] - Solve A*X=B for symmetric positive definite matrices
//! - [`gels`] - Least squares solver
//!
//! ## Singular Value Decomposition ([`lapack::svd`])
//! - [`gesvd`] - Compute singular value decomposition
//!
//! ## Eigenvalue Computations ([`lapack::eigenvalue`])
//! - [`syev`] - Eigenvalues of real symmetric matrices
//! - [`heev`] - Eigenvalues of complex Hermitian matrices
//!
//! ## Orthogonal/Unitary Operations ([`lapack::orthogonal`])
//! - [`orgqr`] / [`ungqr`] - Generate Q matrix from QR factorization
//! - [`ormqr`] / [`unmqr`] - Apply Q matrix from QR factorization
//!
//! # Type Support
//!
//! All operations support multiple precision types:
//! - `f32` - Single precision real
//! - `f64` - Double precision real
//! - [`Complex32`] - Single precision complex
//! - [`Complex64`] - Double precision complex
//!
//! # Batched Operations
//!
//! Most operations have three variants:
//! - Regular (single matrix)
//! - Batched (array of pointers to matrices)
//! - Strided batched (contiguous memory with stride)
//!
//! # Example
//!
//! ```rust,no_run
//! use rocm_rs::{hip::DeviceMemory, rocblas::Handle, rocsolver};
//!
//! // Create a handle (shared with rocBLAS)
//! let handle = Handle::new().unwrap();
//!
//! // Allocate device memory for a 4x3 matrix
//! let m = 4i32;
//! let n = 3i32;
//! let mut A = DeviceMemory::<f64>::new((m * n) as usize).unwrap();
//! let mut tau = DeviceMemory::<f64>::new(n as usize).unwrap();
//! let mut info = DeviceMemory::<i32>::new(1).unwrap();
//!
//! // Compute QR factorization
//! rocsolver::geqrf(&handle, m, n, &mut A, m, &mut tau).unwrap();
//! ```

// Raw FFI bindings generated by bindgen
#[allow(
    non_upper_case_globals,
    non_camel_case_types,
    non_snake_case,
    dead_code,
    clippy::all
)]
pub mod bindings;

// Safe wrapper modules
pub mod error;
pub mod ffi;
pub mod lapack;
pub mod types;

// Re-export Handle from rocBLAS for convenience
// rocSOLVER uses rocblas_handle internally
pub use crate::rocblas::Handle;

// Re-export error types
pub use error::{Error, Result};

// Re-export type-safe enums
pub use types::{
    AlgMode, Complex32, Complex64, Direct, Eform, Eorder, Erange, Esort, Evect, Srange, Storev,
    Svect, Workmode,
};

// Re-export all LAPACK functions at the module level for convenience

// Decompositions
pub use lapack::decompositions::{
    gebrd, gebrd_batched, gebrd_strided_batched, geqrf, geqrf_batched, geqrf_strided_batched,
    getrf, getrf_batched, getrf_npvt, getrf_npvt_batched, getrf_npvt_strided_batched,
    getrf_strided_batched, potrf, potrf_batched, potrf_strided_batched,
};

// Trait re-exports for generic programming
pub use lapack::decompositions::{GebrdType, GeqrfType, GetrfType, PotrfType};

// Solvers
pub use lapack::solvers::{
    gels, gels_batched, gels_strided_batched, gesv, gesv_batched, gesv_strided_batched, getrs,
    getrs_batched, getrs_strided_batched, posv, posv_batched, posv_strided_batched,
};

pub use lapack::solvers::{GelsType, GesvType, GetrsType, PosvType};

// SVD (batched variants not yet implemented due to complex stride requirements)
pub use lapack::svd::gesvd;

pub use lapack::svd::GesvdType;

// Eigenvalue
pub use lapack::eigenvalue::{
    heev, heev_batched, heev_strided_batched, syev, syev_batched, syev_strided_batched,
};

pub use lapack::eigenvalue::{HeevType, SyevType};

// Orthogonal/Unitary (no batched variants available in rocSOLVER)
pub use lapack::orthogonal::{orgqr, ormqr, ungqr, unmqr};

pub use lapack::orthogonal::{OrgqrType, OrmqrType, UngqrType, UnmqrType};
